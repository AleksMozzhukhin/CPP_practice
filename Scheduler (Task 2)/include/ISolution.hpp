// include/ISolution.hpp
#pragma once

#include <memory>
#include <cstdint>

namespace sched {

    /**
     * @brief Тип для значений целевой функции.
     *
     * Для задачи расписания это будет сумма времён завершения всех работ (критерий K2),
     * что по порядку величины может достигать десятков миллионов и выше.
     * long long (signed 64-bit) достаточно безопасен.
     */
    using CostType = long long;

    /**
     * @brief Абстракция "решения", с которым работает имитация отжига.
     *
     * Требования к конкретной реализации (например, расписанию работ на процессоры):
     *  - Хранить текущее состояние решения (например, назначение работ по процессорам).
     *  - Уметь вычислять свою целевую функцию (стоимость).
     *  - Уметь клонироваться (глубокое копирование).
     *
     * Алгоритм имитации отжига (SimulatedAnnealing) обменивается объектами через
     * указатели на базовый класс ISolution.
     *
     * Обратите внимание:
     *  - Конкретные реализации могут кэшировать значение cost() для ускорения.
     *  - Конкретные реализации обязаны быть самодостаточными: clone() должен вернуть
     *    новый независимый объект (deep copy), не зависящий от времени жизни исходного.
     */
    class ISolution {
    public:
        virtual ~ISolution() = default;

        /**
         * @brief Вернуть значение целевой функции.
         *
         * Для задачи расписания это будет критерий K2 = сумма времён завершения всех работ.
         * Чем меньше, тем лучше.
         */
        virtual CostType cost() const = 0;

        /**
         * @brief Создать глубокую копию текущего решения.
         *
         * Возвращаемый объект должен быть полностью независимым (никаких шареных
         * внутренних ссылок, которые могут неожиданно измениться).
         */
        virtual std::unique_ptr<ISolution> clone() const = 0;
    };

} // namespace sched

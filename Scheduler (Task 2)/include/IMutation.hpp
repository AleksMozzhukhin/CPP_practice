// include/IMutation.hpp
#pragma once

#include "ISolution.hpp"

#include <memory>
#include <random>

namespace sched {

    /**
     * @brief Абстрактный интерфейс "оператора мутации" (генератора соседнего решения)
     * для алгоритма имитации отжига.
     *
     * Идея:
     *   - Есть текущее решение src (любая конкретная реализация ISolution).
     *   - Мы хотим получить "соседа" — т.е. немного изменённое решение.
     *   - Это изменение должно сохранять корректность решения в терминах предметной области.
     *
     * Требования к реализации:
     *   - mutate() не изменяет входной объект src.
     *   - mutate() создаёт новый объект-решение (обычно через clone()) и затем
     *     вносит локальное случайное изменение.
     *   - Возвращаемое решение обязано быть допустимым (корректным) с точки зрения задачи.
     *
     * Параметр rng:
     *   - Генератор случайных чисел (std::mt19937_64), который передаётся снаружи,
     *     чтобы управлять воспроизводимостью/сидом на уровне имитации отжига.
     */
    class IMutation {
    public:
        virtual ~IMutation() = default;

        /**
         * @brief Сгенерировать соседнее решение.
         *
         * @param src  Текущее решение.
         * @param rng  ГПСЧ (объект std::mt19937_64), используемый для случайного выбора шага мутации.
         *
         * @return Указатель на новое решение (уже модифицированное).
         *
         * Гарантии:
         *   - Возвращаемый объект не должен зависеть от времени жизни src.
         *   - Возвращаемое решение должно быть корректным (isValid()==true для конкретной задачи),
         *     иначе алгоритм имитации отжига может работать некорректно.
         *
         * В случае принципиально невозможной мутации (что нежелательно в корректном дизайне),
         * реализация может бросить исключение std::runtime_error.
         */
        virtual std::unique_ptr<ISolution> mutate(
            const ISolution& src,
            std::mt19937_64& rng
        ) const = 0;
    };

} // namespace sched
